%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                                     %%
%%                This file is part of the CAPH Compiler distribution                  %%
%%                            http:%/caph.univ-bpclermont.fr                           %%
%%                                                                                     %%
%%                                  Jocelyn SEROT                                      %%
%%                         Jocelyn.Serot@univ-bpclermont.fr                            %%
%%                                                                                     %%
%%         Copyright 2011-2018 Jocelyn SEROT.  All rights reserved.                    %%
%%  This file is distributed under the terms of the GNU Library General Public License %%
%%      with the special exception on linking described in file ..%LICENSE.            %%
%%                                                                                     %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Implementation of variant types}
\label{cha:variants-impl}

This chapter gives a very brief overview of how \caph variant type declarations are translated into
SystemC and VHDL code. The casual programmer is normally not concerned with this.

For this, we take the example of the (polymorphic) \verb|option| type introduced in
Sec.~\ref{sec:type-declarations} :

\begin{verbatim}
type $t option = 
  Absent
| Present of $t
\end{verbatim}

\medskip The code generated by the SystemC backend when this type is instanciated with
\verb|t=signed<8>|, for example, is given in listing~\ref{lst:optiont-cpp}\footnote{This code is
  produced in file \texttt{xxx\_globals.h}, where \texttt{xxx} is the name of the top module.}. The
underlying representation is basically a structure with one field for the tag and the other for the
associated data. The inlined \texttt{iostream} operators are used to read (resp. write) input and
output data to text files.

\begin{lstlisting}[language=C++,frame=single,numbers=left,caption={Code generated by the SystemC
    backend for the \texttt{option} type declaration},label={lst:optiont-cpp}]
class t_option_int8 {
public:
  enum t_tag { Absent, Present };
  struct t_data { sc_int<8> present;  };
  struct { t_tag tag; t_data data; } repr;
  ~t_option() { };
  t_option(void) { };
  t_option(_tag<Absent>) { repr.tag = Absent; };
  t_option(_tag<Present>, sc_int<8> v) { repr.tag = Present; repr.data.present = v; };
  inline friend ::std::ostream& operator << ( ::std::ostream& os, const t_option<sc_int<8> >& v) {
    switch ( v.repr.tag ) {
      case Absent: os << "Absent "; return os;
      case Present: os << "Present " <<  v.repr.data.present; return os;
      }
    }
  inline friend ::std::istream& operator >> ( ::std::istream& is, t_option<sc_int<8> >& v) {
    char tmp[64];
    is >> tmp;
    if ( is.good() ) {
      if ( !strcmp(tmp,"Absent") ) { v.repr.tag=Absent; return is;}
      if ( !strcmp(tmp,"Present") ) { v.repr.tag=Present; is >> v.repr.data.present; return is;}
      }
    }
};
\end{lstlisting}

\bigskip The code generated by the VHDL backend\footnote{In file \texttt{xxx\_types.vhd}, where
  \texttt{xxx} is the name of the top module.} is given in
listing~\ref{lst:optiont-vhd}.  The generated package includes three kinds of
functions :
\begin{itemize}
\item inspectors, for testing if the binary representation\footnote{A \texttt{std\_logic\_vector}}
  of a value matches a given tag (\verb|is_xxx|),
\item injectors, for building the binary representation of an \texttt{option} value (\verb|mk_xxx|),
\item extractors, for extracting the data part of a constructed value (\verb|get_xxx|).
\end{itemize}

As can be observed\footnote{And detailed in Tab.~\ref{tab:type-transl}}, 
variant types are encoded by concatenating a \emph{tag} part and a \emph{data} part.

The \emph{tag}
part (MSBs) contains an integer representing the tag of the encoded value. By default, this integer is 0
for the first tag, 1 for the second, \emph{etc.} It is possible to specify a custom encoding
when declaring the type\footnote{This feature is typically used when the values of the variant type
  are read/written by dedicated processes at the VHDL level, which must know the actual bit-level
  encoding of values.}. For example, to have the \verb|Absent| tag represented as 1 and the
\verb|Present| tag represented as 0, one could have defined the \verb|option| type as :

\begin{verbatim}
type $t option = 
  Absent %1
| Present %0 of $t
\end{verbatim}

The data associated to each distinct tag are encoded in the \emph{data part} (LSBs).

\begin{lstlisting}[language=VHDL,frame=single,numbers=left,caption={Code generated by the VHDL
    backend for the \texttt{option} type declaration},label={lst:optiont-vhd}]
package option_int8 is
  function is_absent(t: std_logic_vector) return boolean;
  function is_present(t: std_logic_vector) return boolean;
  constant mk_absent: std_logic_vector(8 downto 0) := "0" & to_std_logic_vector(to_signed(0,8),8);
  function mk_present(d: signed(7 downto 0)) return std_logic_vector;
  function get_present(t: std_logic_vector) return signed;
end option_int8;

package body option_int8 is

  function is_absent(t: std_logic_vector) return boolean is
  begin
    return t(8 downto 8) = "0";
  end;

  function is_present(t: std_logic_vector) return boolean is
  begin
    return t(8 downto 8) = "1";
  end;

  function mk_present(d: signed(7 downto 0)) return std_logic_vector is
  begin
    return "1" & to_std_logic_vector(d,8);
  end;

  function get_present(t: std_logic_vector) return signed is
  begin
    return from_std_logic_vector(t(7 downto 0),8);
  end;

end package body option_int8;
\end{lstlisting}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "caph"
%%% End: 
